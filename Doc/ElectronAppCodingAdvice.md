# JavaScript建议

- 每当我们注册一个事件，就要考虑是否要卸载这个事件
  - 如果我们在某个事件（事件A）内注册另一个事件（事件B）（比如：在点击按钮或组件初始化时注册某个事件）
    - 那就要考虑这个事件A会被频繁的触发吗？如果是，就要考虑事件被多次注册，导致的内存泄露的问题了
  - 原则上来说，除了全局事件之外，其他所有事件都应该有对应的`取消注册`逻辑
  - 基于此原则：如果用户的某个操作，会创建某个占用内存的资源，那么就要考虑如何回收这个资源
    - 避免用户不断操作，不断创建资源，造成内存泄露
  - 基于此原则：应尽量避免为大量子元素注册相同的事件处理程序
    - 尤其是那些由用户操作动态创建的子元素，我们无法确定到底会出现多少个这样的子元素
      - 比如：聊天消息对应的Dom元素，
    - 我们可以考虑为父元素注册一个事件，以处理所有子元素的同一事件
      - 判断e.target，以确定是哪个子元素的触发的事件
  - 基于此原则：尽量把ipcMain和ipcRenderer监听的同类事件做合并

- 每当我们在闭包函数内使用外部对象时，就考虑此对象是否能被成功释放
  - 如果闭包函数持续被引用（没被释放），那么闭包函数引用的外部对象就得不到释放

- 每当我们要写递归时，都应该考虑是否可以用循环替代
  - 99%的递归都可以用循环代替
  - 循环使用的内存比递归要少的多

- 每当我们读文件时，都应该考虑是否有必要读取这个文件的所有内容
  - 如果文件是用户生成的或者我们不确定文件的大小，就不要一次性读取文件的所有内容
    - 尤其是让一个变量持有这个文件的所有内容，不要这样做。
  - 考虑分块处理文件内容，以满足需求
    - 比如：文件上传

- 每当我们引入一个外部库的时候，要考虑一下这个库是否真的是我们需要的
  - 有些外部库包含大量我们用不到的代码，而且这些代码没办法被tree-shake掉
    - 比如axios兼容各大浏览器的代码，对于Chromium用户来说完全没有意义
  - 库和框架不但会带来性能和资源消耗的问题，还会干扰我们定位问题
  - 先考虑自己实现的难度和成本，再考虑引入外部库

- 尽量避免使用以Sync结尾的函数
  - Node.js和Electron提供了很多这样的函数
  - 这类函数会阻塞JavaScript执行进程，不但会影响性能，还会影响业务的正确性，也可能会导致崩溃
  - 基于此：我们也应该慎用那些小于100毫秒的定时器（Interval）

- 如果没有必要，不要开Web Worker或者Worker Threads
  - 除非我们写了代码，验证过不开线程就无法满足某个业务需求时，再考虑开新线程
  - 这不但是内存资源消耗的问题，还有很多线程带来的复杂性问题，比如线程同步

- 一个大对象，用的时候创建，用完丢弃（等着被垃圾收集），往往比把这个对象声明成一个缓存对象（全局对象）要好
  - 即使要频繁使用这个对象，大多数情况下，也不应该缓存这个对象
  - 多消耗点用户的CPU（按需消耗），少消耗点用户的内存（长期消耗）

- 对于发生频率非常高的事件，考虑使用节流、防抖，控制资源消耗
  - 即使事件处理函数没做繁重的工作也应该这么做

- Fetch/XHR会影响客户端的性能
  - 协调服务端，尽量使用粗粒度的API，尽量以少量的请求获取更多的数据。
  - 遇到请求异常的情况，尝试几次失败后，尽量想别的办法，不要频繁的尝试

- 对业务逻辑进程抽象、封装，提供公共基类或方法的前提，应该时不制造额外的消耗（尽量）
  - 抽象、封装的目的是复用代码，减轻开发人员的工作量
  - 然而如果这个工作导致了难以排查的问题，那就事与愿违了。

# HTML/CSS 建议

- 每当我们移除一个Dom元素时，都应考虑是否还有js代码引用着这个Dom
  - 如果有，这个Dom对象就释放不了，而且它引用的整个Dom树都释放不了

- 矢量图标资源的使用
  - 图标资源，如果不是多色图标的话，建议使用字体图标
    - 只需要一个ttf文件即可，不要把WOFF文件也搞进来
    - 在提供矢量能力的前提下，比svg图标要小的多，也不会占用大量的Dom资源
  - 如果需要多色，但不需要矢量能力，那就做成图片，尽量不要使用svg
    - 如果这样的图片很多，考虑制作雪碧图
  - 如果要用svg，那么不显示的时候，不要把它附加到Dom树上
  - 如果使用js把svg插入到Dom树中，那么我们的js会长久持有svg对应的字符串吗？不要这样做。

- 不需要显示的Dom尽量不要挂在Dom树上
  - 等需要显示此Dom时,再用JS动态创建它不迟
  - 尽量不要用显/隐的方式控制这类需求
    - Chromium排版、渲染足够快，一般不会影响用户体验
    - 多消耗点用户的CPU（按需消耗），少消耗点用户的内存（长期消耗）

# 工具建议

- 生产环境尽量不要在控制台打印日志
  - 打印日志这项工作会占用JS执行线程，影响性能；
  - 打印的日志会占用额外的内存
  - 即使浏览器会控制打印日志的数量，也难保打印的对象是否引用了其他对象；
    - 比如：我们打印了一个JS对象，这个对象可能又引用了其他对象，所有这些被引用的对象都不会被释放；

- 打包时拆分chunk
  - 每个chunk文件大小建议不要超过300k
  - 如果文件编译后的产物过大，程序加载该Chunk的时间就会变长，内存消耗也会变大。
  - 有些用户永远不会使用某些功能，那么对应的chunk也永远不会被加载到内存中
    - 这与我们的预期相符，用户不应为他们永不会使用的功能支付内存
  
- 使用tree-shake能力
  - 外部模块提供了很多能力，与项目无关的能力就应该被tree-shake掉
  - 原则上打包后的asar文件里，不应该存在node_modules目录
    - 对于一些包含原生能力的模块，应该考虑使用electron-builder的extraResources配置打包到应用中
    - Electron项目99%的模块都应该是开发依赖（devDependencies），而不是生产依赖（dependencies）

- 多用Chrome Debug工具分析内存消耗
  - 对于Electron应用来说，内存问题比性能问题要重要的多
  - 制定内存优化目标，比如以JS内存消耗30M为目标，根据目标优化代码

- 收集崩溃报告使用WinDbg分析崩溃问题

